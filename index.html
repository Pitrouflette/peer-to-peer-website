<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Chat Example</title>
</head>
<body>
  <h1>WebRTC Chat Example</h1>

  <div id="chat-messages"></div>
  <input type="text" id="messageInput" placeholder="Type your message...">
  <button onclick="sendMessage()">Send</button>
  <input type="text" id="IDInput" placeholder="the id you wish to connect to">
  <button id="initiateConnectionBtn">connect</button>

  <div id="userIdDisplay">Your ID: <span id="userId"></span></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
  <script>
    const socket = io();
    const chatMessagesContainer = document.getElementById('chat-messages');
    const messageInput = document.getElementById('messageInput');
    let peerConnection;

    socket.on('connect', () => {
      console.log('Connected to server');

      document.getElementById('initiateConnectionBtn').addEventListener('click', () => {
        if (document.getElementById('IDInput').value){
            console.log('Connecting...');
            initiateConnection(document.getElementById('IDInput').value);
        }
      });
      document.getElementById('userId').innerText = socket.id;
    });

    socket.on('offer', (offer, sourceSocketId) => {
      handleOffer(offer, sourceSocketId);
    });

    socket.on('answer', (answer, targetSocketId) => {
      handleAnswer(answer, targetSocketId);
    });

    socket.on('ice-candidate', (candidate, targetSocketId) => {
      handleIceCandidate(candidate, targetSocketId);
    });

    function initiateConnection(targetSocketId) {
        if (peerConnection && peerConnection.signalingState !== 'closed') {
            console.warn('La connexion existe déjà.');
            return;
        }

        peerConnection = new RTCPeerConnection();
        const dataChannel = peerConnection.createDataChannel('chat');
        setupDataChannel(dataChannel);

        peerConnection.onnegotiationneeded = () => {
            peerConnection.createOffer()
                .then((offer) => peerConnection.setLocalDescription(offer))
                .then(() => {
                    socket.emit('offer', peerConnection.localDescription, targetSocketId);
                    console.log("offer sent !");
                })
                .catch((error) => {
                    console.error('Erreur lors de la création de l\'offre:', error);
                    closeConnection();
                });
        };
        document.getElementById('userIdDisplay').innerText = `Your ID: ${socket.id}, Connected to: ${targetSocketId}`;
    }



    function closeConnection() {
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    }

    function setupDataChannel(dataChannel) {
      dataChannel.onmessage = (event) => {
        displayMessage('Other User', event.data);
      };

      dataChannel.onopen = () => {
        console.log('Le canal de données est ouvert');
      };

      dataChannel.onclose = () => {
        console.log('Le canal de données est fermé');
      };
      console.log("conected !");
    }

    function handleOffer(offer, sourceSocketId) {
        console.log("Handling connection....");
        
        if (!peerConnection) {
            console.log("no peer connexion found, recreating one");
            initiateConnection();
        }

        if (peerConnection.signalingState === 'stable') {
            console.log("stable connection");
            peerConnection.setRemoteDescription(offer)
            .then(() => peerConnection.createAnswer())
            .then((answer) => peerConnection.setLocalDescription(answer))
            .then(() => {
                socket.emit('answer', peerConnection.localDescription);
                console.log("awnser sent !");
            })
            .catch((error) => {
                console.error('Error handling offer:', error);
            });
        } else {
            console.warn('The connection is not in a proper state to accept the offer currently.');
        }
        document.getElementById('userIdDisplay').innerText = `Your ID: ${socket.id}, Connected to: ${sourceSocketId}`;
    }


    function handleAnswer(answer) {
      peerConnection.setRemoteDescription(answer)
        .catch((error) => {
          console.error('Erreur lors de la gestion de la réponse:', error);
        });
    }

    function handleIceCandidate(candidate) {
      peerConnection.addIceCandidate(candidate)
        .catch((error) => {
          console.error('Erreur lors de la gestion du candidat ICE:', error);
        });
    }

    function sendMessage() {
        console.log('sending message..');
        const message = messageInput.value.trim();
        
        if (message !== '') {
            console.log('message verified');
            if(!peerConnection) {
                console.log("no peer conexion..");
                return;
            }
            
            if(!peerConnection.dataChannel) {
                console.log("no dataChannel.. creating a new one !");
                const dataChannel = peerConnection.createDataChannel('chat');
                setupDataChannel(dataChannel);
                console.log("created !");
            }

            console.log('peer connection verified');
            peerConnection.dataChannel.send(message);
            displayMessage('You', message);
            messageInput.value = '';
            console.log('message sent !');

        }
    }
    function displayMessage(sender, message) {
      const chatMessages = document.createElement('div');
      chatMessages.innerHTML = `<strong>${sender}:</strong> ${message}`;
      chatMessagesContainer.appendChild(chatMessages);
    }
  </script>
</body>
</html>